#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-9;
bool equal(double a, double b)
{
    return abs(a - b) < eps;
}

struct V
{
    double x, y;
    V(double x = 0, double y = 0) : x(x), y(y) {}
    V operator+(const V &p) const
    {
        return V(x + p.x, y + p.y);
    }
    V operator-(const V &p) const
    {
        return V(x - p.x, y - p.y);
    }
    V operator*(double a) const
    {
        return V(x * a, y * a);
    }
    double sqrNorm() const
    {
        return x * x + y * y;
    }
    double norm() const
    {
        return sqrt(sqrNorm());
    }
    V rotate90() const
    {
        return V(y, -x);
    }
};

struct Circle
{
    V o;
    double r;
    Circle(V o = V(), double r = 0.0) : o(o), r(r) {}
    vector<V> xp(const Circle &c)
    {
        V v = c.o - o;
        double l = v.norm();
        if (equal(l, 0.0))
        {
            return {};
        }
        if (equal(l + r + c.r, max({l, r, c.r}) * 2))
        {
            if (equal(l + r, c.r))
            {
                return {o - v * (r / l)};
            }
            else
            {
                return {o + v * (r / l)};
            }
        }
        if (l + r + c.r < max({l, r, c.r}) * 2 + eps)
        {
            return {};
        }
        double x = -(c.r * c.r - l * l - r * r) / (2 * l);
        double y = sqrt(r * r - x * x);
        V mid = o + v * (x / l);
        v = v.rotate90();
        return {mid + v * (y / l), mid - v * (y / l)};
    }
    bool isInside(const V &p)
    {
        return (p - o).norm() < r + eps;
    }
};

void solve(int N, int K, std::vector<Circle> c)
{
    if (K == 1)
    {
        cout << 0 << endl;
        return;
    }

    double l = 0.0, r = 400000.0;

    for (int ti = 0; ti < 100; ti++)
    {
        double x = (l + r) / 2.0;
        vector<V> ps;

        for (int i = 0; i < N; i++)
        {
            ps.push_back(c[i].o);
        }

        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < i; j++)
            {
                Circle a = c[i], b = c[j];
                a.r = x / a.r;
                b.r = x / b.r;
                auto tmp = a.xp(b);
                ps.insert(ps.end(), tmp.begin(), tmp.end());
            }
        }
        bool ok = false;
        for (V p : ps)
        {
            int cnt = 0;
            for (int ci = 0; ci < N; ci++)
            {
                Circle nc = c[ci];
                nc.r = x / nc.r;
                if (nc.isInside(p))
                {
                    cnt++;
                }
            }
            if (cnt >= K)
            {
                ok = true;
            }
        }
        if (ok)
        {
            r = x;
            // cout << "r = " << r << endl;
        }
        else
        {
            l = x;
            // cout << "l = " << l << endl;
        }
    }
    cout << setprecision(10) << r << endl;
    return;
}

// Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main()
{
    int N = 0;
    cin >> N;
    int K = 0;
    cin >> K;

    vector<Circle> c(N);
    // std::vector<long long> x(N);
    // std::vector<long long> y(N);
    // std::vector<long long> c(N);
    for (int i = 0; i < N; i++)
    {
        cin >> c[i].o.x >> c[i].o.y >> c[i].r;
    }
    solve(N, K, std::move(c));
    return 0;
}
